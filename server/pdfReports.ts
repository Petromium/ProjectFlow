import PdfPrinter from 'pdfmake';
import type { TDocumentDefinitions, Content, TableCell, Style, StyleDictionary, TFontDictionary } from 'pdfmake/interfaces';
import type { Project, Risk, Issue, Task, CostItem, Stakeholder } from '@shared/schema';
import path from 'path';

const fontsDir = path.join(process.cwd(), 'server', 'fonts');

const fonts: TFontDictionary = {
  Roboto: {
    normal: path.join(fontsDir, 'Roboto-Regular.ttf'),
    bold: path.join(fontsDir, 'Roboto-Medium.ttf'),
    italics: path.join(fontsDir, 'Roboto-Italic.ttf'),
    bolditalics: path.join(fontsDir, 'Roboto-MediumItalic.ttf')
  }
};

const printer = new PdfPrinter(fonts);

const styles: StyleDictionary = {
  header: {
    fontSize: 24,
    bold: true,
    color: '#1a365d',
    margin: [0, 0, 0, 10]
  },
  subheader: {
    fontSize: 16,
    bold: true,
    color: '#2d3748',
    margin: [0, 15, 0, 8]
  },
  sectionTitle: {
    fontSize: 14,
    bold: true,
    color: '#4a5568',
    margin: [0, 10, 0, 5]
  },
  tableHeader: {
    fontSize: 10,
    bold: true,
    fillColor: '#e2e8f0',
    color: '#1a202c'
  },
  tableCell: {
    fontSize: 9,
    color: '#4a5568'
  },
  footer: {
    fontSize: 8,
    color: '#718096',
    alignment: 'center' as const
  },
  projectInfo: {
    fontSize: 11,
    color: '#4a5568',
    margin: [0, 2, 0, 2]
  },
  statusHigh: {
    fontSize: 9,
    bold: true,
    color: '#c53030'
  },
  statusMedium: {
    fontSize: 9,
    bold: true,
    color: '#d69e2e'
  },
  statusLow: {
    fontSize: 9,
    bold: true,
    color: '#38a169'
  },
  metricValue: {
    fontSize: 18,
    bold: true,
    color: '#2d3748'
  },
  metricLabel: {
    fontSize: 10,
    color: '#718096'
  }
};

function formatDate(date: Date | string | null | undefined): string {
  if (!date) return 'N/A';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

function formatCurrency(amount: number | string | null | undefined, currency: string = 'USD'): string {
  if (amount === null || amount === undefined) return 'N/A';
  const num = typeof amount === 'string' ? parseFloat(amount) : amount;
  return new Intl.NumberFormat('en-US', { style: 'currency', currency }).format(num);
}

function getImpactColor(impact: string): string {
  switch (impact) {
    case 'critical': return '#c53030';
    case 'high': return '#dd6b20';
    case 'medium': return '#d69e2e';
    case 'low': return '#38a169';
    default: return '#718096';
  }
}

function getPriorityColor(priority: string): string {
  switch (priority) {
    case 'critical': return '#c53030';
    case 'high': return '#dd6b20';
    case 'medium': return '#d69e2e';
    case 'low': return '#38a169';
    default: return '#718096';
  }
}

function createHeader(title: string, project: Project, reportDate: Date): Content[] {
  return [
    {
      columns: [
        {
          text: title,
          style: 'header',
          width: '*'
        },
        {
          text: `Report Date: ${formatDate(reportDate)}`,
          alignment: 'right' as const,
          fontSize: 10,
          color: '#718096',
          width: 'auto'
        }
      ]
    },
    {
      canvas: [{ type: 'line', x1: 0, y1: 0, x2: 515, y2: 0, lineWidth: 2, lineColor: '#3182ce' }]
    },
    { text: '', margin: [0, 10, 0, 0] },
    {
      columns: [
        {
          stack: [
            { text: `Project: ${project.name}`, style: 'projectInfo', bold: true },
            { text: `Code: ${project.code}`, style: 'projectInfo' },
            { text: `Status: ${project.status}`, style: 'projectInfo' }
          ],
          width: '*'
        },
        {
          stack: [
            { text: `Start Date: ${formatDate(project.startDate)}`, style: 'projectInfo' },
            { text: `End Date: ${formatDate(project.endDate)}`, style: 'projectInfo' },
            { text: `Budget: ${formatCurrency(project.budget, project.currency)}`, style: 'projectInfo' }
          ],
          width: 'auto'
        }
      ]
    },
    { text: '', margin: [0, 15, 0, 0] }
  ];
}

function createFooter(currentPage: number, pageCount: number): Content {
  return {
    columns: [
      { text: 'Generated by EPC PMIS', style: 'footer', width: '*' },
      { text: `Page ${currentPage} of ${pageCount}`, style: 'footer', alignment: 'right' as const, width: 'auto' }
    ],
    margin: [40, 0, 40, 0]
  };
}

export interface RiskRegisterReportData {
  project: Project;
  risks: Risk[];
  generatedBy: string;
}

export function generateRiskRegisterReport(data: RiskRegisterReportData): PDFKit.PDFDocument {
  const { project, risks, generatedBy } = data;
  const reportDate = new Date();

  const risksByStatus = {
    identified: risks.filter(r => r.status === 'identified'),
    assessed: risks.filter(r => r.status === 'assessed'),
    mitigating: risks.filter(r => r.status === 'mitigating'),
    closed: risks.filter(r => r.status === 'closed')
  };

  const highRisks = risks.filter(r => r.impact === 'high' || r.impact === 'critical');
  const avgProbability = risks.length > 0 
    ? (risks.reduce((sum, r) => sum + (r.probability || 3), 0) / risks.length).toFixed(1)
    : '0';

  const tableBody: TableCell[][] = [
    [
      { text: 'Code', style: 'tableHeader' },
      { text: 'Title', style: 'tableHeader' },
      { text: 'Category', style: 'tableHeader' },
      { text: 'Status', style: 'tableHeader' },
      { text: 'Prob.', style: 'tableHeader' },
      { text: 'Impact', style: 'tableHeader' },
      { text: 'Mitigation Plan', style: 'tableHeader' }
    ]
  ];

  risks.forEach(risk => {
    tableBody.push([
      { text: risk.code, style: 'tableCell' },
      { text: risk.title, style: 'tableCell' },
      { text: risk.category || 'N/A', style: 'tableCell' },
      { text: risk.status, style: 'tableCell' },
      { text: `${risk.probability}/5`, style: 'tableCell' },
      { text: risk.impact, style: 'tableCell', color: getImpactColor(risk.impact) },
      { text: risk.mitigationPlan || 'Not defined', style: 'tableCell', noWrap: false }
    ]);
  });

  const docDefinition: TDocumentDefinitions = {
    pageSize: 'A4',
    pageOrientation: 'landscape',
    pageMargins: [40, 60, 40, 60],
    styles,
    content: [
      ...createHeader('Risk Register Report', project, reportDate),
      
      { text: 'Executive Summary', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: risks.length.toString(), style: 'metricValue' },
              { text: 'Total Risks', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: highRisks.length.toString(), style: 'metricValue', color: '#c53030' },
              { text: 'High/Critical Risks', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: avgProbability, style: 'metricValue' },
              { text: 'Avg Probability (1-5)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: risksByStatus.closed.length.toString(), style: 'metricValue', color: '#38a169' },
              { text: 'Closed Risks', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Risk Register', style: 'subheader' },
      risks.length > 0 ? {
        table: {
          headerRows: 1,
          widths: [50, 100, 70, 60, 40, 50, '*'],
          body: tableBody
        },
        layout: {
          fillColor: (rowIndex: number) => rowIndex === 0 ? '#e2e8f0' : (rowIndex % 2 === 0 ? '#f7fafc' : null)
        }
      } : { text: 'No risks registered for this project.', style: 'tableCell', italics: true },

      { text: '', pageBreak: 'after' },
      
      { text: 'Risk Distribution by Status', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: 'Identified', style: 'sectionTitle' },
              { text: `${risksByStatus.identified.length} risks`, style: 'projectInfo' }
            ],
            width: '*'
          },
          {
            stack: [
              { text: 'Assessed', style: 'sectionTitle' },
              { text: `${risksByStatus.assessed.length} risks`, style: 'projectInfo' }
            ],
            width: '*'
          },
          {
            stack: [
              { text: 'Mitigating', style: 'sectionTitle' },
              { text: `${risksByStatus.mitigating.length} risks`, style: 'projectInfo' }
            ],
            width: '*'
          },
          {
            stack: [
              { text: 'Closed', style: 'sectionTitle' },
              { text: `${risksByStatus.closed.length} risks`, style: 'projectInfo' }
            ],
            width: '*'
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: `Report generated by: ${generatedBy}`, style: 'footer', margin: [0, 30, 0, 0] }
    ],
    footer: createFooter
  };

  return printer.createPdfKitDocument(docDefinition);
}

export interface ProjectStatusReportData {
  project: Project;
  tasks: Task[];
  risks: Risk[];
  issues: Issue[];
  costItems: CostItem[];
  generatedBy: string;
}

export function generateProjectStatusReport(data: ProjectStatusReportData): PDFKit.PDFDocument {
  const { project, tasks, risks, issues, costItems, generatedBy } = data;
  const reportDate = new Date();

  const tasksByStatus = {
    notStarted: tasks.filter(t => t.status === 'not-started'),
    inProgress: tasks.filter(t => t.status === 'in-progress'),
    review: tasks.filter(t => t.status === 'review'),
    completed: tasks.filter(t => t.status === 'completed'),
    onHold: tasks.filter(t => t.status === 'on-hold')
  };

  const completionRate = tasks.length > 0 
    ? ((tasksByStatus.completed.length / tasks.length) * 100).toFixed(1)
    : '0';

  const avgProgress = tasks.length > 0
    ? (tasks.reduce((sum, t) => sum + (t.progress || 0), 0) / tasks.length).toFixed(1)
    : '0';

  const openIssues = issues.filter(i => i.status === 'open' || i.status === 'in-progress');
  const activeRisks = risks.filter(r => r.status !== 'closed');

  const totalBudgeted = costItems.reduce((sum, c) => sum + parseFloat(c.budgeted?.toString() || '0'), 0);
  const totalActual = costItems.reduce((sum, c) => sum + parseFloat(c.actual?.toString() || '0'), 0);
  const costVariance = totalBudgeted - totalActual;

  const taskTableBody: TableCell[][] = [
    [
      { text: 'WBS', style: 'tableHeader' },
      { text: 'Task Name', style: 'tableHeader' },
      { text: 'Status', style: 'tableHeader' },
      { text: 'Priority', style: 'tableHeader' },
      { text: 'Progress', style: 'tableHeader' },
      { text: 'Start Date', style: 'tableHeader' },
      { text: 'End Date', style: 'tableHeader' }
    ]
  ];

  tasks.slice(0, 20).forEach(task => {
    taskTableBody.push([
      { text: task.wbsCode, style: 'tableCell' },
      { text: task.name, style: 'tableCell' },
      { text: task.status, style: 'tableCell' },
      { text: task.priority, style: 'tableCell', color: getPriorityColor(task.priority) },
      { text: `${task.progress}%`, style: 'tableCell' },
      { text: formatDate(task.startDate), style: 'tableCell' },
      { text: formatDate(task.endDate), style: 'tableCell' }
    ]);
  });

  const docDefinition: TDocumentDefinitions = {
    pageSize: 'A4',
    pageOrientation: 'portrait',
    pageMargins: [40, 60, 40, 60],
    styles,
    content: [
      ...createHeader('Project Status Report', project, reportDate),

      { text: 'Executive Summary', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: `${completionRate}%`, style: 'metricValue', color: '#3182ce' },
              { text: 'Task Completion', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: `${avgProgress}%`, style: 'metricValue' },
              { text: 'Avg Progress', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: openIssues.length.toString(), style: 'metricValue', color: openIssues.length > 0 ? '#dd6b20' : '#38a169' },
              { text: 'Open Issues', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: activeRisks.length.toString(), style: 'metricValue', color: activeRisks.length > 5 ? '#c53030' : '#718096' },
              { text: 'Active Risks', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Task Status Overview', style: 'subheader' },
      {
        columns: [
          { text: `Not Started: ${tasksByStatus.notStarted.length}`, style: 'projectInfo', width: '*' },
          { text: `In Progress: ${tasksByStatus.inProgress.length}`, style: 'projectInfo', width: '*' },
          { text: `Completed: ${tasksByStatus.completed.length}`, style: 'projectInfo', width: '*' },
          { text: `On Hold: ${tasksByStatus.onHold.length}`, style: 'projectInfo', width: '*' }
        ],
        margin: [0, 5, 0, 15]
      },

      { text: 'Budget Summary', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: formatCurrency(totalBudgeted, project.currency), style: 'metricValue', fontSize: 14 },
              { text: 'Total Budgeted', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(totalActual, project.currency), style: 'metricValue', fontSize: 14 },
              { text: 'Total Actual', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(costVariance, project.currency), style: 'metricValue', fontSize: 14, color: costVariance >= 0 ? '#38a169' : '#c53030' },
              { text: 'Variance', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Task Details (Top 20)', style: 'subheader' },
      tasks.length > 0 ? {
        table: {
          headerRows: 1,
          widths: [50, '*', 60, 50, 50, 60, 60],
          body: taskTableBody
        },
        layout: {
          fillColor: (rowIndex: number) => rowIndex === 0 ? '#e2e8f0' : (rowIndex % 2 === 0 ? '#f7fafc' : null)
        }
      } : { text: 'No tasks found for this project.', style: 'tableCell', italics: true },

      { text: `Report generated by: ${generatedBy}`, style: 'footer', margin: [0, 30, 0, 0] }
    ],
    footer: createFooter
  };

  return printer.createPdfKitDocument(docDefinition);
}

export interface EVAReportData {
  project: Project;
  tasks: Task[];
  costItems: CostItem[];
  generatedBy: string;
}

export function generateEVAReport(data: EVAReportData): PDFKit.PDFDocument {
  const { project, tasks, costItems, generatedBy } = data;
  const reportDate = new Date();

  const totalBudget = parseFloat(project.budget?.toString() || '0');
  const totalBudgeted = costItems.reduce((sum, c) => sum + parseFloat(c.budgeted?.toString() || '0'), 0);
  const totalActual = costItems.reduce((sum, c) => sum + parseFloat(c.actual?.toString() || '0'), 0);
  
  const avgProgress = tasks.length > 0
    ? tasks.reduce((sum, t) => sum + (t.progress || 0), 0) / tasks.length
    : 0;

  const plannedValue = totalBudget;
  const earnedValue = totalBudget * (avgProgress / 100);
  const actualCost = totalActual;

  const scheduleVariance = earnedValue - plannedValue * (avgProgress / 100);
  const costVariance = earnedValue - actualCost;
  
  const schedulePerformanceIndex = plannedValue > 0 ? earnedValue / (plannedValue * (avgProgress / 100)) : 0;
  const costPerformanceIndex = actualCost > 0 ? earnedValue / actualCost : 0;

  const estimateAtCompletion = costPerformanceIndex > 0 ? totalBudget / costPerformanceIndex : totalBudget;
  const estimateToComplete = estimateAtCompletion - actualCost;
  const varianceAtCompletion = totalBudget - estimateAtCompletion;

  const costBreakdown = costItems.reduce((acc, item) => {
    const category = item.category || 'Other';
    if (!acc[category]) {
      acc[category] = { budgeted: 0, actual: 0 };
    }
    acc[category].budgeted += parseFloat(item.budgeted?.toString() || '0');
    acc[category].actual += parseFloat(item.actual?.toString() || '0');
    return acc;
  }, {} as Record<string, { budgeted: number; actual: number }>);

  const costTableBody: TableCell[][] = [
    [
      { text: 'Category', style: 'tableHeader' },
      { text: 'Budgeted', style: 'tableHeader' },
      { text: 'Actual', style: 'tableHeader' },
      { text: 'Variance', style: 'tableHeader' },
      { text: '% of Budget', style: 'tableHeader' }
    ]
  ];

  Object.entries(costBreakdown).forEach(([category, values]) => {
    const variance = values.budgeted - values.actual;
    const pctOfBudget = values.budgeted > 0 ? ((values.actual / values.budgeted) * 100).toFixed(1) : '0';
    costTableBody.push([
      { text: category, style: 'tableCell' },
      { text: formatCurrency(values.budgeted, project.currency), style: 'tableCell' },
      { text: formatCurrency(values.actual, project.currency), style: 'tableCell' },
      { text: formatCurrency(variance, project.currency), style: 'tableCell', color: variance >= 0 ? '#38a169' : '#c53030' },
      { text: `${pctOfBudget}%`, style: 'tableCell' }
    ]);
  });

  const docDefinition: TDocumentDefinitions = {
    pageSize: 'A4',
    pageOrientation: 'portrait',
    pageMargins: [40, 60, 40, 60],
    styles,
    content: [
      ...createHeader('Earned Value Analysis Report', project, reportDate),

      { text: 'Key Performance Indicators', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: formatCurrency(plannedValue, project.currency), style: 'metricValue', fontSize: 14 },
              { text: 'Planned Value (PV)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(earnedValue, project.currency), style: 'metricValue', fontSize: 14, color: '#3182ce' },
              { text: 'Earned Value (EV)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(actualCost, project.currency), style: 'metricValue', fontSize: 14 },
              { text: 'Actual Cost (AC)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Variance Analysis', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: formatCurrency(scheduleVariance, project.currency), style: 'metricValue', fontSize: 14, color: scheduleVariance >= 0 ? '#38a169' : '#c53030' },
              { text: 'Schedule Variance (SV)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(costVariance, project.currency), style: 'metricValue', fontSize: 14, color: costVariance >= 0 ? '#38a169' : '#c53030' },
              { text: 'Cost Variance (CV)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Performance Indices', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: schedulePerformanceIndex.toFixed(2), style: 'metricValue', fontSize: 14, color: schedulePerformanceIndex >= 1 ? '#38a169' : '#c53030' },
              { text: 'Schedule Performance Index (SPI)', style: 'metricLabel' },
              { text: schedulePerformanceIndex >= 1 ? 'Ahead of Schedule' : 'Behind Schedule', style: 'projectInfo', color: schedulePerformanceIndex >= 1 ? '#38a169' : '#c53030' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: costPerformanceIndex.toFixed(2), style: 'metricValue', fontSize: 14, color: costPerformanceIndex >= 1 ? '#38a169' : '#c53030' },
              { text: 'Cost Performance Index (CPI)', style: 'metricLabel' },
              { text: costPerformanceIndex >= 1 ? 'Under Budget' : 'Over Budget', style: 'projectInfo', color: costPerformanceIndex >= 1 ? '#38a169' : '#c53030' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Forecasting', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: formatCurrency(estimateAtCompletion, project.currency), style: 'metricValue', fontSize: 12 },
              { text: 'Estimate at Completion (EAC)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(estimateToComplete, project.currency), style: 'metricValue', fontSize: 12 },
              { text: 'Estimate to Complete (ETC)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: formatCurrency(varianceAtCompletion, project.currency), style: 'metricValue', fontSize: 12, color: varianceAtCompletion >= 0 ? '#38a169' : '#c53030' },
              { text: 'Variance at Completion (VAC)', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Cost Breakdown by Category', style: 'subheader' },
      Object.keys(costBreakdown).length > 0 ? {
        table: {
          headerRows: 1,
          widths: ['*', 'auto', 'auto', 'auto', 'auto'],
          body: costTableBody
        },
        layout: {
          fillColor: (rowIndex: number) => rowIndex === 0 ? '#e2e8f0' : (rowIndex % 2 === 0 ? '#f7fafc' : null)
        }
      } : { text: 'No cost items recorded for this project.', style: 'tableCell', italics: true },

      { text: `Report generated by: ${generatedBy}`, style: 'footer', margin: [0, 30, 0, 0] }
    ],
    footer: createFooter
  };

  return printer.createPdfKitDocument(docDefinition);
}

export interface IssueLogReportData {
  project: Project;
  issues: Issue[];
  generatedBy: string;
}

export function generateIssueLogReport(data: IssueLogReportData): PDFKit.PDFDocument {
  const { project, issues, generatedBy } = data;
  const reportDate = new Date();

  const issuesByStatus = {
    open: issues.filter(i => i.status === 'open'),
    inProgress: issues.filter(i => i.status === 'in-progress'),
    resolved: issues.filter(i => i.status === 'resolved'),
    closed: issues.filter(i => i.status === 'closed')
  };

  const issuesByPriority = {
    critical: issues.filter(i => i.priority === 'critical'),
    high: issues.filter(i => i.priority === 'high'),
    medium: issues.filter(i => i.priority === 'medium'),
    low: issues.filter(i => i.priority === 'low')
  };

  const tableBody: TableCell[][] = [
    [
      { text: 'Code', style: 'tableHeader' },
      { text: 'Title', style: 'tableHeader' },
      { text: 'Status', style: 'tableHeader' },
      { text: 'Priority', style: 'tableHeader' },
      { text: 'Category', style: 'tableHeader' },
      { text: 'Reported Date', style: 'tableHeader' },
      { text: 'Resolution', style: 'tableHeader' }
    ]
  ];

  issues.forEach(issue => {
    tableBody.push([
      { text: issue.code, style: 'tableCell' },
      { text: issue.title, style: 'tableCell' },
      { text: issue.status, style: 'tableCell' },
      { text: issue.priority, style: 'tableCell', color: getPriorityColor(issue.priority) },
      { text: issue.category || 'N/A', style: 'tableCell' },
      { text: formatDate(issue.reportedDate), style: 'tableCell' },
      { text: issue.resolution || 'Pending', style: 'tableCell' }
    ]);
  });

  const docDefinition: TDocumentDefinitions = {
    pageSize: 'A4',
    pageOrientation: 'landscape',
    pageMargins: [40, 60, 40, 60],
    styles,
    content: [
      ...createHeader('Issue Log Report', project, reportDate),

      { text: 'Executive Summary', style: 'subheader' },
      {
        columns: [
          {
            stack: [
              { text: issues.length.toString(), style: 'metricValue' },
              { text: 'Total Issues', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: issuesByStatus.open.length.toString(), style: 'metricValue', color: '#dd6b20' },
              { text: 'Open Issues', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: issuesByPriority.critical.length.toString(), style: 'metricValue', color: '#c53030' },
              { text: 'Critical Priority', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          },
          {
            stack: [
              { text: issuesByStatus.resolved.length.toString(), style: 'metricValue', color: '#38a169' },
              { text: 'Resolved Issues', style: 'metricLabel' }
            ],
            width: '*',
            alignment: 'center' as const
          }
        ],
        margin: [0, 10, 0, 20]
      },

      { text: 'Issue Log', style: 'subheader' },
      issues.length > 0 ? {
        table: {
          headerRows: 1,
          widths: [50, '*', 60, 50, 70, 70, 100],
          body: tableBody
        },
        layout: {
          fillColor: (rowIndex: number) => rowIndex === 0 ? '#e2e8f0' : (rowIndex % 2 === 0 ? '#f7fafc' : null)
        }
      } : { text: 'No issues logged for this project.', style: 'tableCell', italics: true },

      { text: `Report generated by: ${generatedBy}`, style: 'footer', margin: [0, 30, 0, 0] }
    ],
    footer: createFooter
  };

  return printer.createPdfKitDocument(docDefinition);
}
